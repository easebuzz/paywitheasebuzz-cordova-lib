// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target i386-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Easebuzz
import Darwin
@_exported import Easebuzz
import Foundation
import ObjectiveC
import Security
import Swift
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Easebuzz.SHA1 : Easebuzz.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers open class CardValidator {
  public enum CardType : Swift.Int {
    case amex
    case visa
    case mastercard
    case discover
    case dinersClub
    case maestro
    case elo
    case visaelectron
    case forbrugsforeningen
    case dankort
    case rupay
    case unionpay
    case jcb
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum CardError : Swift.Error {
    case unsupported
    case invalid
    public static func == (a: Easebuzz.CardValidator.CardError, b: Easebuzz.CardValidator.CardError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
extension Easebuzz.CardValidator.CardType {
  public func stringValue() -> Swift.String
  public init?(string: Swift.String)
}
extension Swift.String {
  public func isValidCardNumber() -> Swift.Bool
  public func cardType() -> Easebuzz.CardValidator.CardType?
  public func validLength() -> Swift.Int
  public func formattedCardNumber() -> Swift.String
  public var length: Swift.String {
    get
  }
  public var pairs: [Swift.String] {
    get
  }
  public var expiryDate: [Swift.String] {
    get
  }
  public var amountFormatter: Swift.String {
    get
  }
  public func validDate() -> Swift.Bool
}
extension Foundation.NSMutableURLRequest {
  public func setBodyContent(parameters: [Swift.String : Any])
}
@_inheritsConvenienceInitializers @objc public class StaticDataModel : ObjectiveC.NSObject {
  @objc public static let TXN_SUCCESS_CODE: Swift.String
  @objc public static let TXN_FAILED_CODE: Swift.String
  @objc public static let TXN_TIMEOUT_CODE: Swift.String
  @objc public static let TXN_BACKPRESSED_CODE: Swift.String
  @objc public static let TXN_USERCANCELLED_CODE: Swift.String
  @objc public static let TXN_USER_FAILED_CODE: Swift.String
  @objc public static let TXN_ERROR_SERVER_ERROR_CODE: Swift.String
  @objc public static let TXN_ERROR_NO_RETRY_CODE: Swift.String
  @objc public static let TXN_ERROR_TXN_NOT_ALLOWED_CODE: Swift.String
  @objc public static let TXN_INVALID_INPUT_DATA_CODE: Swift.String
  @objc public static let TXN_ERROR_RETRY_FAILED_CODE: Swift.String
  @objc public static let TXN_SESSION_STARTED_CODE: Swift.String
  @objc public static let TXN_SESSION_EXPIRED_CODE: Swift.String
  @objc public static let TXN_SESSION_CANCELLED_CODE_TRUE: Swift.String
  @objc public static let TXN_SESSION_CANCELLED_CODE_FALSE: Swift.String
  @objc public static let TXN_BANK_BACK_PRESSED_CODE: Swift.String
  @objc public static let TXN_UPI_CANCELLED_CODE: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) public class Spinner : UIKit.UIVisualEffectView {
  @_Concurrency.MainActor(unsafe) public init(text: Swift.String)
  @_Concurrency.MainActor(unsafe) public func setText(text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) public func show()
  @_Concurrency.MainActor(unsafe) public func hide()
  @objc deinit
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
@available(*, deprecated, renamed: "SwiftyJSONError.errorDomain", message: "ErrorDomain is deprecated. Use `SwiftyJSONError.errorDomain` instead.")
public let ErrorDomain: Swift.String
@available(*, deprecated, renamed: "SwiftyJSONError.unsupportedType", message: "ErrorUnsupportedType is deprecated. Use `SwiftyJSONError.unsupportedType` instead.")
public let ErrorUnsupportedType: Swift.Int
@available(*, deprecated, renamed: "SwiftyJSONError.indexOutOfBounds", message: "ErrorIndexOutOfBounds is deprecated. Use `SwiftyJSONError.indexOutOfBounds` instead.")
public let ErrorIndexOutOfBounds: Swift.Int
@available(*, deprecated, renamed: "SwiftyJSONError.wrongType", message: "ErrorWrongType is deprecated. Use `SwiftyJSONError.wrongType` instead.")
public let ErrorWrongType: Swift.Int
@available(*, deprecated, renamed: "SwiftyJSONError.notExist", message: "ErrorNotExist is deprecated. Use `SwiftyJSONError.notExist` instead.")
public let ErrorNotExist: Swift.Int
@available(*, deprecated, renamed: "SwiftyJSONError.invalidJSON", message: "ErrorInvalidJSON is deprecated. Use `SwiftyJSONError.invalidJSON` instead.")
public let ErrorInvalidJSON: Swift.Int
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Easebuzz.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  @available(*, deprecated, message: "Use instead `init(parseJSON: )`")
  public static func parse(_ json: Swift.String) -> Easebuzz.JSON
  public mutating func merge(with other: Easebuzz.JSON) throws
  public func merged(with other: Easebuzz.JSON) throws -> Easebuzz.JSON
  public var type: Easebuzz.`Type` {
    get
  }
  public var error: Easebuzz.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: Easebuzz.JSON {
    get
  }
  public static var null: Easebuzz.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: Easebuzz.Index<T>, rhs: Easebuzz.Index<T>) -> Swift.Bool
  public static func < (lhs: Easebuzz.Index<T>, rhs: Easebuzz.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = Easebuzz.Index<Easebuzz.JSON>
public typealias JSONRawIndex = Easebuzz.Index<Any>
extension Easebuzz.JSON : Swift.Collection {
  public typealias Index = Easebuzz.JSONRawIndex
  public var startIndex: Easebuzz.JSON.Index {
    get
  }
  public var endIndex: Easebuzz.JSON.Index {
    get
  }
  public func index(after i: Easebuzz.JSON.Index) -> Easebuzz.JSON.Index
  public subscript(position: Easebuzz.JSON.Index) -> (Swift.String, Easebuzz.JSON) {
    get
  }
  public typealias Element = (Swift.String, Easebuzz.JSON)
  public typealias Indices = Swift.DefaultIndices<Easebuzz.JSON>
  public typealias Iterator = Swift.IndexingIterator<Easebuzz.JSON>
  public typealias SubSequence = Swift.Slice<Easebuzz.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: Easebuzz.JSONKey { get }
}
extension Swift.Int : Easebuzz.JSONSubscriptType {
  public var jsonKey: Easebuzz.JSONKey {
    get
  }
}
extension Swift.String : Easebuzz.JSONSubscriptType {
  public var jsonKey: Easebuzz.JSONKey {
    get
  }
}
extension Easebuzz.JSON {
  public subscript(path: [Easebuzz.JSONSubscriptType]) -> Easebuzz.JSON {
    get
    set
  }
  public subscript(path: Easebuzz.JSONSubscriptType...) -> Easebuzz.JSON {
    get
    set
  }
}
extension Easebuzz.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Easebuzz.JSON.StringLiteralType)
  public init(unicodeScalarLiteral value: Easebuzz.JSON.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Easebuzz.JSON.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Easebuzz.JSON.StringLiteralType
}
extension Easebuzz.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension Easebuzz.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension Easebuzz.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension Easebuzz.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension Easebuzz.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Easebuzz.JSON : Swift.ExpressibleByNilLiteral {
  @available(*, deprecated, message: "use JSON.null instead. Will be removed in future versions")
  public init(nilLiteral: ())
}
extension Easebuzz.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [Easebuzz.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension Easebuzz.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Easebuzz.JSON {
  public var array: [Easebuzz.JSON]? {
    get
  }
  public var arrayValue: [Easebuzz.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var dictionary: [Swift.String : Easebuzz.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : Easebuzz.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension Easebuzz.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension Easebuzz.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension Easebuzz.JSON : Swift.Comparable {
}
public func == (lhs: Easebuzz.JSON, rhs: Easebuzz.JSON) -> Swift.Bool
public func <= (lhs: Easebuzz.JSON, rhs: Easebuzz.JSON) -> Swift.Bool
public func >= (lhs: Easebuzz.JSON, rhs: Easebuzz.JSON) -> Swift.Bool
public func > (lhs: Easebuzz.JSON, rhs: Easebuzz.JSON) -> Swift.Bool
public func < (lhs: Easebuzz.JSON, rhs: Easebuzz.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: Easebuzz.writingOptionsKeys, b: Easebuzz.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Easebuzz.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: Easebuzz.Padding = .pkcs7) throws
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: Easebuzz.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Easebuzz.CTR.Error, b: Easebuzz.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
@_inheritsConvenienceInitializers @objc(EBZDropDown) @_Concurrency.MainActor(unsafe) open class EBZDropDown : UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) public var selectedIndex: Swift.Int?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var rowHeight: CoreGraphics.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var rowBackgroundColor: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var selectedRowColor: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var hideOptionsWhenSelect: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var isSearchEnable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var borderColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var listHeight: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var borderWidth: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var cornerRadius: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var optionArray: [Swift.String] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var optionImageArray: [Swift.String] {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var optionIds: [Swift.Int]?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var arrowSize: CoreGraphics.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var arrowColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var checkMarkEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var handleKeyboard: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func showList()
  @_Concurrency.MainActor(unsafe) public func hideList()
  @objc @_Concurrency.MainActor(unsafe) public func touchAction()
  @_Concurrency.MainActor(unsafe) public func didSelect(completion: @escaping (_ selectedText: Swift.String, _ index: Swift.Int, _ id: Swift.Int) -> ())
  @_Concurrency.MainActor(unsafe) public func listWillAppear(completion: @escaping () -> ())
  @_Concurrency.MainActor(unsafe) public func listDidAppear(completion: @escaping () -> ())
  @_Concurrency.MainActor(unsafe) public func listWillDisappear(completion: @escaping () -> ())
  @_Concurrency.MainActor(unsafe) public func listDidDisappear(completion: @escaping () -> ())
}
extension Easebuzz.EBZDropDown : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
extension Easebuzz.EBZDropDown : UIKit.UITableViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
extension Easebuzz.EBZDropDown : UIKit.UITableViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
}
public struct PCBC : Easebuzz.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Easebuzz.PCBC.Error, b: Easebuzz.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : Easebuzz.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: Easebuzz.Padding, b: Easebuzz.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PKCS5 {
}
@_hasMissingDesignatedInitializers public class Logger {
  public static func logError(tag: Swift.String, message: Swift.String)
  public static func logDebug(tag: Swift.String, message: Swift.String)
  public static func enableLog(enable: Swift.Bool)
  @objc deinit
}
extension Easebuzz.AES : Easebuzz.Cryptors {
  final public func makeEncryptor() throws -> Easebuzz.Cryptor & Easebuzz.Updatable
  final public func makeDecryptor() throws -> Easebuzz.Cryptor & Easebuzz.Updatable
}
public struct CFB : Easebuzz.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Easebuzz.CFB.Error, b: Easebuzz.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: Easebuzz.ChaCha20.Error, b: Easebuzz.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension Easebuzz.ChaCha20 : Easebuzz.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Easebuzz.ChaCha20 {
  public struct ChaChaEncryptor : Easebuzz.Cryptor, Easebuzz.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension Easebuzz.ChaCha20 {
  public struct ChaChaDecryptor : Easebuzz.Cryptor, Easebuzz.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension Easebuzz.ChaCha20 : Easebuzz.Cryptors {
  final public func makeEncryptor() -> Easebuzz.Cryptor & Easebuzz.Updatable
  final public func makeDecryptor() -> Easebuzz.Cryptor & Easebuzz.Updatable
}
final public class Poly1305 : Easebuzz.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: Easebuzz.Poly1305.Error, b: Easebuzz.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: Easebuzz.AES.Error, b: Easebuzz.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: Easebuzz.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: Easebuzz.BlockMode, padding: Easebuzz.Padding = .pkcs7) throws
  @objc deinit
}
extension Easebuzz.AES : Easebuzz.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: Easebuzz.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: Easebuzz.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: Easebuzz.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : Easebuzz.Authenticator
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension Easebuzz.Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public struct ECB : Easebuzz.BlockMode {
  public let options: Easebuzz.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: Easebuzz.SHA3.Variant, b: Easebuzz.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: Easebuzz.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Easebuzz.SHA3 : Easebuzz.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public func decryptBase64ToString(cipher: Easebuzz.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: Easebuzz.Cipher) throws -> Swift.Array<Swift.UInt8>
}
extension Easebuzz.HMAC {
  convenience public init(key: Swift.String, variant: Easebuzz.HMAC.Variant = .md5) throws
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : Easebuzz._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [Easebuzz.Bit]
  public func bits() -> Swift.String
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> Easebuzz.Cryptor & Easebuzz.Updatable
  func makeDecryptor() throws -> Easebuzz.Cryptor & Easebuzz.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Easebuzz.Cryptors {
  public static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
final public class GCM : Easebuzz.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: Easebuzz.GCM.Mode, b: Easebuzz.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: Easebuzz.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: Easebuzz.GCM.Error, b: Easebuzz.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: Easebuzz.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: Easebuzz.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
  @objc deinit
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var shouldAutorotate: Swift.Bool {
    @_Concurrency.MainActor(unsafe) @objc get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
}
@objc public protocol PayWithEasebuzzCallback : ObjectiveC.NSObjectProtocol {
  @objc func PEBCallback(data: [Swift.String : Swift.AnyObject])
}
@_inheritsConvenienceInitializers @objc public class PayWithEasebuzz : ObjectiveC.NSObject {
  @objc public class func setUp(pebCallback: Easebuzz.PayWithEasebuzzCallback)
  @objc public class func initiliazed() -> Swift.Bool
  @objc public class func invokePaymentOptionsView(paymentObj: Easebuzz.Payment, isFrom: Any)
  @objc override dynamic public init()
  @objc deinit
}
public struct OFB : Easebuzz.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Easebuzz.OFB.Error, b: Easebuzz.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: Easebuzz.CipherError, b: Easebuzz.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Easebuzz.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: Easebuzz.Rabbit.Error, b: Easebuzz.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Easebuzz.Rabbit : Easebuzz.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: Easebuzz.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: Easebuzz.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: Easebuzz.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: Easebuzz.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class MonthYearPickerView : UIKit.UIPickerView, UIKit.UIPickerViewDelegate, UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor(unsafe) public var onDateSelected: ((_ month: Swift.Int, _ year: Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func pickerView(_ pickerView: UIKit.UIPickerView, titleForRow row: Swift.Int, forComponent component: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent component: Swift.Int)
  @_Concurrency.MainActor(unsafe) @objc public func pickerView(_ pickerView: UIKit.UIPickerView, attributedTitleForRow row: Swift.Int, forComponent component: Swift.Int) -> Foundation.NSAttributedString?
  @objc deinit
}
extension Easebuzz.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: Easebuzz.Padding = .pkcs7) throws
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : Easebuzz.Cryptor, Easebuzz.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension Easebuzz.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: Easebuzz.PKCS5.PBKDF2.Error, b: Easebuzz.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: Easebuzz.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: Easebuzz.CCM.Error, b: Easebuzz.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
extension Easebuzz.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: Easebuzz.PKCS5.PBKDF1.Error, b: Easebuzz.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: Easebuzz.PKCS5.PBKDF1.Variant, b: Easebuzz.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: Easebuzz.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
@objc @_inheritsConvenienceInitializers open class RSAUtils : ObjectiveC.NSObject {
  public static func encryptWithRSAKey(_ data: Foundation.Data, rsaKeyRef: Security.SecKey, padding: Security.SecPadding) -> Foundation.Data?
  public static func decryptWithRSAKey(_ encryptedData: Foundation.Data, rsaKeyRef: Security.SecKey, padding: Security.SecPadding) -> Foundation.Data?
  public static func deleteRSAKeyFromKeychain(_ tagName: Swift.String)
  public static func getRSAKeyFromKeychain(_ tagName: Swift.String) -> Security.SecKey?
  public static func addRSAPrivateKey(_ privkeyBase64: Swift.String, tagName: Swift.String) -> Security.SecKey?
  public static func addRSAPublicKey(_ pubkeyBase64: Swift.String, tagName: Swift.String) -> Security.SecKey?
  public static func encryptWithRSAPrivateKey(_ data: Foundation.Data, privkeyBase64: Swift.String, keychainTag: Swift.String) -> Foundation.Data?
  public static func encryptWithRSAPublicKey(_ data: Foundation.Data, pubkeyBase64: Swift.String, keychainTag: Swift.String) -> Foundation.Data?
  public static func decryptWithRSAPrivateKey(_ encryptedData: Foundation.Data, privkeyBase64: Swift.String, keychainTag: Swift.String) -> Foundation.Data?
  public static func decryptWithRSAPublicKey(_ encryptedData: Foundation.Data, pubkeyBase64: Swift.String, keychainTag: Swift.String) -> Foundation.Data?
  @objc override dynamic public init()
  @objc deinit
}
extension Easebuzz.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class HMAC : Easebuzz.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: Easebuzz.HMAC.Error, b: Easebuzz.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: Easebuzz.HMAC.Variant, b: Easebuzz.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: Easebuzz.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Easebuzz.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Easebuzz.MD5 : Easebuzz.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : Easebuzz.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum PKCS7 {
}
public protocol CipherModeWorker {
  var cipherOperation: Easebuzz.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : Easebuzz.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : Easebuzz.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : Easebuzz.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : Easebuzz.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : Easebuzz.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : Easebuzz.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = Easebuzz.BlockModeOption
  public typealias Element = Easebuzz.BlockModeOption
  public typealias RawValue = Swift.Int
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: Easebuzz.Blowfish.Error, b: Easebuzz.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: Easebuzz.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: Easebuzz.Padding) throws
  @objc deinit
}
extension Easebuzz.Blowfish : Easebuzz.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: Easebuzz.HKDF.Error, b: Easebuzz.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: Easebuzz.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers final public class CMAC : Easebuzz.CBCMAC {
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: Easebuzz.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: Easebuzz.SHA2.Variant.RawValue)
  }
  public init(variant: Easebuzz.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Easebuzz.SHA2 : Easebuzz.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.Array {
  public init(reserveCapacity: Swift.Int)
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: Easebuzz.SHA2.Variant) -> [Element]
  public func sha3(_ variant: Easebuzz.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: Easebuzz.Cipher) throws -> [Element]
  public func decrypt(cipher: Easebuzz.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : Easebuzz.Authenticator
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = ToastManager.shared.duration, position: Easebuzz.ToastPosition = ToastManager.shared.position, title: Swift.String? = nil, image: UIKit.UIImage? = nil, style: Easebuzz.ToastStyle = ToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = ToastManager.shared.duration, point: CoreGraphics.CGPoint, title: Swift.String?, image: UIKit.UIImage?, style: Easebuzz.ToastStyle = ToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = ToastManager.shared.duration, position: Easebuzz.ToastPosition = ToastManager.shared.position, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = ToastManager.shared.duration, point: CoreGraphics.CGPoint, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func hideToast()
  @_Concurrency.MainActor(unsafe) public func hideToast(_ toast: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func hideAllToasts(includeActivity: Swift.Bool = false, clearQueue: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func clearToastQueue()
  @_Concurrency.MainActor(unsafe) public func makeToastActivity(_ position: Easebuzz.ToastPosition)
  @_Concurrency.MainActor(unsafe) public func makeToastActivity(_ point: CoreGraphics.CGPoint)
  @_Concurrency.MainActor(unsafe) public func hideToastActivity()
  @_Concurrency.MainActor(unsafe) public func toastViewForMessage(_ message: Swift.String?, title: Swift.String?, image: UIKit.UIImage?, style: Easebuzz.ToastStyle) throws -> UIKit.UIView
}
public struct ToastStyle {
  public init()
  public var backgroundColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var messageColor: UIKit.UIColor
  public var maxWidthPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var maxHeightPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var horizontalPadding: CoreGraphics.CGFloat
  public var verticalPadding: CoreGraphics.CGFloat
  public var cornerRadius: CoreGraphics.CGFloat
  public var titleFont: UIKit.UIFont
  public var messageFont: UIKit.UIFont
  public var titleAlignment: UIKit.NSTextAlignment
  public var messageAlignment: UIKit.NSTextAlignment
  public var titleNumberOfLines: Swift.Int
  public var messageNumberOfLines: Swift.Int
  public var displayShadow: Swift.Bool
  public var shadowColor: UIKit.UIColor
  public var shadowOpacity: Swift.Float {
    get
    set
  }
  public var shadowRadius: CoreGraphics.CGFloat
  public var shadowOffset: CoreGraphics.CGSize
  public var imageSize: CoreGraphics.CGSize
  public var activitySize: CoreGraphics.CGSize
  public var fadeDuration: Swift.Double
  public var activityIndicatorColor: UIKit.UIColor
  public var activityBackgroundColor: UIKit.UIColor
}
@_hasMissingDesignatedInitializers public class ToastManager {
  public static let shared: Easebuzz.ToastManager
  public var style: Easebuzz.ToastStyle
  public var isTapToDismissEnabled: Swift.Bool
  public var isQueueEnabled: Swift.Bool
  public var duration: Swift.Double
  public var position: Easebuzz.ToastPosition
  @objc deinit
}
public enum ToastPosition {
  case top
  case center
  case bottom
  public static func == (a: Easebuzz.ToastPosition, b: Easebuzz.ToastPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class Payment : ObjectiveC.NSObject {
  @objc public init(customerData: Swift.Dictionary<Swift.String, Any>)
  public func isValid() -> (validity: Swift.Bool, error: Swift.String)
  @objc public func isValid() -> Swift.Bool
  public func isValidTxnId() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidTxnId() -> Foundation.NSDictionary
  public func isValidAmount() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidAmount() -> Foundation.NSDictionary
  public func isValidName() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidName() -> Foundation.NSDictionary
  public func isValidPhone() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidPhone() -> Foundation.NSDictionary
  public func isValidProductInfo() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidProductInfo() -> Foundation.NSDictionary
  public func isValidEmail() -> (validity: Swift.Bool, error: Swift.String)
  public func isValidEmail() -> Foundation.NSDictionary
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public class CBCMAC : Easebuzz.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: Easebuzz.CBCMAC.Error, b: Easebuzz.CBCMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Easebuzz.Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
@available(*, renamed: "Digest")
public typealias Hash = Easebuzz.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: Easebuzz.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: Easebuzz.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public struct CBC : Easebuzz.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Easebuzz.CBC.Error, b: Easebuzz.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Easebuzz.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Easebuzz.CipherOperationOnBlock) throws -> Easebuzz.CipherModeWorker
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
extension Easebuzz.CardValidator.CardType : Swift.Equatable {}
extension Easebuzz.CardValidator.CardType : Swift.Hashable {}
extension Easebuzz.CardValidator.CardType : Swift.RawRepresentable {}
extension Easebuzz.CardValidator.CardError : Swift.Equatable {}
extension Easebuzz.CardValidator.CardError : Swift.Hashable {}
extension Easebuzz.SwiftyJSONError : Swift.Equatable {}
extension Easebuzz.SwiftyJSONError : Swift.Hashable {}
extension Easebuzz.SwiftyJSONError : Swift.RawRepresentable {}
extension Easebuzz.`Type` : Swift.Equatable {}
extension Easebuzz.`Type` : Swift.Hashable {}
extension Easebuzz.`Type` : Swift.RawRepresentable {}
extension Easebuzz.writingOptionsKeys : Swift.Equatable {}
extension Easebuzz.writingOptionsKeys : Swift.Hashable {}
extension Easebuzz.CTR : Easebuzz.BlockMode {}
extension Easebuzz.CTR.Error : Swift.Equatable {}
extension Easebuzz.CTR.Error : Swift.Hashable {}
extension Easebuzz.PCBC.Error : Swift.Equatable {}
extension Easebuzz.PCBC.Error : Swift.Hashable {}
extension Easebuzz.Padding : Swift.Equatable {}
extension Easebuzz.Padding : Swift.Hashable {}
extension Easebuzz.CFB.Error : Swift.Equatable {}
extension Easebuzz.CFB.Error : Swift.Hashable {}
extension Easebuzz.ChaCha20.Error : Swift.Equatable {}
extension Easebuzz.ChaCha20.Error : Swift.Hashable {}
extension Easebuzz.Poly1305.Error : Swift.Equatable {}
extension Easebuzz.Poly1305.Error : Swift.Hashable {}
extension Easebuzz.AES.Error : Swift.Equatable {}
extension Easebuzz.AES.Error : Swift.Hashable {}
extension Easebuzz.AES.Variant : Swift.Equatable {}
extension Easebuzz.AES.Variant : Swift.Hashable {}
extension Easebuzz.AES.Variant : Swift.RawRepresentable {}
extension Easebuzz.Bit : Swift.Equatable {}
extension Easebuzz.Bit : Swift.Hashable {}
extension Easebuzz.Bit : Swift.RawRepresentable {}
extension Easebuzz.SHA3.Variant : Swift.Equatable {}
extension Easebuzz.SHA3.Variant : Swift.Hashable {}
extension Easebuzz.GCM.Mode : Swift.Equatable {}
extension Easebuzz.GCM.Mode : Swift.Hashable {}
extension Easebuzz.GCM.Error : Swift.Equatable {}
extension Easebuzz.GCM.Error : Swift.Hashable {}
extension Easebuzz.OFB.Error : Swift.Equatable {}
extension Easebuzz.OFB.Error : Swift.Hashable {}
extension Easebuzz.CipherError : Swift.Equatable {}
extension Easebuzz.CipherError : Swift.Hashable {}
extension Easebuzz.Rabbit.Error : Swift.Equatable {}
extension Easebuzz.Rabbit.Error : Swift.Hashable {}
extension Easebuzz.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension Easebuzz.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension Easebuzz.CCM : Easebuzz.BlockMode {}
extension Easebuzz.CCM.Error : Swift.Equatable {}
extension Easebuzz.CCM.Error : Swift.Hashable {}
extension Easebuzz.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension Easebuzz.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension Easebuzz.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension Easebuzz.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension Easebuzz.HMAC.Error : Swift.Equatable {}
extension Easebuzz.HMAC.Error : Swift.Hashable {}
extension Easebuzz.HMAC.Variant : Swift.Equatable {}
extension Easebuzz.HMAC.Variant : Swift.Hashable {}
extension Easebuzz.Blowfish.Error : Swift.Equatable {}
extension Easebuzz.Blowfish.Error : Swift.Hashable {}
extension Easebuzz.HKDF.Error : Swift.Equatable {}
extension Easebuzz.HKDF.Error : Swift.Hashable {}
extension Easebuzz.SHA2.Variant : Swift.Equatable {}
extension Easebuzz.SHA2.Variant : Swift.Hashable {}
extension Easebuzz.ToastPosition : Swift.Equatable {}
extension Easebuzz.ToastPosition : Swift.Hashable {}
extension Easebuzz.CBCMAC.Error : Swift.Equatable {}
extension Easebuzz.CBCMAC.Error : Swift.Hashable {}
extension Easebuzz.CBC.Error : Swift.Equatable {}
extension Easebuzz.CBC.Error : Swift.Hashable {}
